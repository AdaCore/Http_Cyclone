\documentclass[a4paper, 10pt]{article}

\author{Guillaume Cluzel}
\title{Toward a secure TCP/IP stack --- Technical report}

\usepackage{amsmath,amsfonts}

\usepackage{listings}

\lstset{
    basicstyle=\ttfamily
}

\usepackage{tikz}
\usetikzlibrary{calc,backgrounds,shapes}
\usetikzlibrary{arrows.meta, shapes.callouts}

\tikzset{global scale/.style={
    scale=#1,
    every node/.style={scale=#1}
  }
}

\usepackage{hyperref}

\usepackage[ruled]{algorithm2e}


\begin{document}

    \maketitle

    \tableofcontents

    \section{Introduction}

    TCP is a widely used network protocol to communicate in the Internet as
    it is used by the HTTP protocol, the FTP protocol, and so many others.
    Ensuring the safety of the TCP/IP stack is essential for the safety of
    a lot of machines. While a lot of work has been done on higher level
    protocols, such as SSL/TLS which is built on top of TCP and designed
    to provide a security layer to TCP that have been the subject of lots of
    works like miTLS \cite{}, nothing has been done to make a secure TCP
    implementation. Nonetheless, TLS security can only be ensured if the underlying
    TCP implementation is free of bugs.

    CycloneTCP is a library developped by Oryx Embedded for embedded platforms.
    A large number of platforms are supported, and the library can be used
    with a dozen of OS. The code of the library is written in C and contains
    plenty protocols from low-level network layers like IPv4/IPv6, to transport layer
    and application layer like DHCP or HTTP. In particular an implementation of
    the TCP protocol is provided.

    SPARK 2014 is a programming language designed as a subset of Ada that helps in
    making high reliability sofwares by providing powerful static analysis methods.
    SPARK is able to detect uninitialized variables with control flow analysis,
    and can ensure the absence of run-time errors,
    but also, based on SMT-solver, functionnal behavior can be specified for every
    functions and mathematically proved.

    The aim of this work was to translate some parts of the CycloneTCP stack
    in Ada/SPARK to improve the safety of the code. In particular we focused
    on the TCP protocol to ensure that the norm is respected in this work.

    This report is a synthesis of the challenge of verifying a such protocol
    and the solution I found to go toward a secure protocol.


    \section{The TCP protocol}

    \subsection{Why verifying a TCP stack?}

    As mentionned in the introduction, TCP protocol is the base of a lot of other protocols,
    in particular SSL/TLS.


    \subsection{Sockets}

    A socket is nothing more than a data structures that contains the connection
    information, like for example the local or the remote IP address as well as
    the state of the connection. In Ada, a socket will be represented by a pointer
    to a record type:

    \begin{lstlisting}[language=Ada]
type Socket_Struct is record
    S_Descriptor     : Sock_Descriptor;
    S_Type           : Socket_Type;
    S_Protocol       : Socket_Protocol;
    S_Net_Interface  : System.Address;
    S_localIpAddr    : IpAddr;
    S_Local_Port     : Port;
    S_Remote_Ip_Addr : IpAddr;
    S_Remote_Port    : Port;
    S_Timeout        : Systime;
    State            : Tcp_State;
    -- Other fields
end record;
type Socket is access Socket_Struct;
    \end{lstlisting}

    A socket is also the structure that is manipulated by the user as an opaque structure,
    through an interface to perform operations on it and perform operations on the
    global environment by sending messages in the network for example.

    \subsection{Presentation of the protocol}

    TCP is defined by the norm RFC 793 \cite{} in a high level language.
    TCP is a realiable, ordered and error-checked connection oriented protocol.
    It means that two computers have to open a connection first before sending data.
    The connection is closed once all the data has been transmitted.
    The flow of a connection (if no error happens) contains three main steps:
    \begin{enumerate}
        \item Opening the connection,
        \item Sending \& receiving the data,
        \item Closing the connection.
    \end{enumerate}

    This mechanism is decribed by a state machine.

    \begin{figure}[p]
        \begin{tikzpicture}[>=latex, global scale=.75]
            
        %
        % Styles for states, and state edges
        %
        \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=8em, font={\sffamily\bfseries}]
        \tikzstyle{stateEdgePortion} = [black,thick];
        \tikzstyle{stateEdge} = [stateEdgePortion,->];
        \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];
        
        %
        % Position States
        %
        \node[state, name=closedStart] {CLOSED};
        \node[state, name=listen, below of=closedStart] {LISTEN};
        \node[state, name=synSent, below of=listen, right of=listen, xshift=8em] {SYN\_SENT};
        \node[state, name=synRcvd, below of=listen, left of=listen, xshift=-8em] {SYN\_RCVD};
        \node[state, name=established, below of=listen, node distance=14em] {ESTABLISHED};
        \node[state, name=finWait1, below of=established, left of=established, node distance=7em, xshift=-9em] {FIN\_WAIT\_1};
        \node[state, name=finWait2, below of=finWait1] {FIN\_WAIT\_2};
        \node[state, name=closeWait, below of=established, right of=established, node distance=7em, xshift=9em] {CLOSE\_WAIT};
        \node[state, name=closing, below of=established, node distance=14em] {CLOSING};
        \node[state, name=lastAck, below of=closeWait] {LAST\_ACK};
        \node[state, name=timeWait, below of=closing] {TIME\_WAIT};
        
        \node at ($(lastAck) + (0,-3)$) {Source: \url{http://www.texample.net}};
        
        %
        % Connect States via edges
        %
        \draw ($(closedStart.south) + (-.5em,0)$) 
        edge[stateEdge] node[edgeLabel, xshift=-3em]{\emph{Passive open}} 
        ($(listen.north) + (-.5em,0)$); 
        \draw ($(listen.north) + (.5em,0)$) 
        edge[stateEdge] node[edgeLabel, xshift=2em]{\emph{Close}} 
        ($(closedStart.south) + (.5em,0)$);
        
        \draw ($(listen.south) + (-1em,0)$) 
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-2em, yshift=1em]{SYN/SYN + ACK} 
        ($(synRcvd.east) + (0,1em)$);
        \draw ($(listen.south) + (1em,0)$) 
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{\emph{Send}/SYN} 
        ($(synSent.west) + (0,1em)$);
        
        \draw ($(synRcvd.north) + (.5em,0)$) 
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=-4em]{\emph{Timeout}/RST} 
        ($(closedStart.west) + (0,-.5em)$);
        
        \draw ($(synSent.north) + (-.5em,0)$) 
        edge[stateEdge, bend right=45] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Close}} 
        ($(closedStart.east) + (0,-.5em)$);
        \draw ($(closedStart.east) + (0,.5em)$) 
        edge[stateEdge, bend left=45] node[edgeLabel,xshift=4em]{\emph{Active open}/SYN} 
        ($(synSent.north) + (.5em,0)$);
        
        \draw (synSent.west) 
        edge[stateEdge] node[edgeLabel, yshift=1em]{SYN/SYN + ACK} 
        (synRcvd.east);
        \draw (synRcvd) 
        edge[stateEdge] node[edgeLabel, xshift=-2.5em]{\emph{Close}/FIN} 
        (finWait1);
        
        \draw ($(synRcvd.east) + (0,-1em)$) 
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=-1em]{ACK} 
        ($(established.north) + (-1em,0)$);
        \draw ($(synSent.west) + (0,-1em)$) 
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=3em, yshift=-1em]{SYN + ACK/ACK} 
        ($(established.north) + (1em,0)$);
        
        \draw ($(established.south) + (-1em,0)$) 
        edge[stateEdge, bend left=22.5] node[edgeLabel, xshift=-1em, yshift=1em]{\emph{Close}/FIN} 
        ($(finWait1.east) + (0,.5em)$);
        \draw ($(established.south) + (1em,0)$) 
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=1em, yshift=1em]{FIN/ACK} 
        ($(closeWait.west) + (0,1em)$);
        
        \draw (finWait1.south) 
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK} 
        (finWait2.north);
        \draw ($(finWait1.east) + (0,-.5em)$) 
        edge[stateEdge, bend left=22.5] node[edgeLabel, yshift=1em]{ACK} 
        (closing.north);
        \draw (finWait1.south east) 
        edge[stateEdge] node[edgeLabel, xshift=1em, yshift=2em, text width=3em]{FIN + ACK/ACK} 
        (timeWait.north west);
        
        \draw (finWait2.south) 
        edge[stateEdge, bend right=22.5] node[edgeLabel, xshift=-2em, yshift=-1em]{FIN/ACK} 
        (timeWait.west);
        
        \draw (closing) 
        edge[stateEdge] node[edgeLabel, xshift=-2em]{ACK} 
        (timeWait);
        
        \draw (closeWait) 
        edge[stateEdge] node[edgeLabel,xshift=2.5em]{\emph{Close}/FIN} 
        (lastAck);
        
        %
        % Connect lastAck to closed is slightly more complicated
        % no direct line-of-sight, so we need to take the scenic route
        %
        \coordinate (lastAck2ClosedA) at ($(lastAck.east) + (2em,0)$);
        \coordinate (lastAck2ClosedB) at ($(closedStart.north -| lastAck.east) + (2em,1em)$);
        \coordinate (lastAck2ClosedC) at ($(closedStart.north) + (0.5em,1em)$);
        \draw (lastAck.east) edge[stateEdgePortion] (lastAck2ClosedA);
        \draw (lastAck2ClosedA) edge[stateEdgePortion] node[edgeLabel,xshift=-1.5em, yshift=-4em]{ACK} (lastAck2ClosedB);
        \draw (lastAck2ClosedB) edge[stateEdgePortion] (lastAck2ClosedC);
        \draw (lastAck2ClosedC) edge[stateEdge] ($(closedStart.north) + (0.5em,0)$);
        
        %
        % likewise for timeWait to closed
        %
        \coordinate (timeWait2ClosedA) at ($(timeWait.south) + (0,-1em)$);
        \coordinate (timeWait2ClosedB) at ($(timeWait.south -| finWait2.west) + (-2em,-1em)$);
        \coordinate (timeWait2ClosedC) at ($(closedStart.north -| finWait2.west) + (-2em,1em)$);
        \coordinate (timeWait2ClosedD) at ($(closedStart.north) + (-0.5em,1em)$);
        \draw (timeWait.south) edge[stateEdgePortion] (timeWait2ClosedA);
        \draw (timeWait2ClosedA) edge[stateEdgePortion] (timeWait2ClosedB);
        \draw (timeWait2ClosedB) edge[stateEdgePortion] (timeWait2ClosedC);
        \draw (timeWait2ClosedC) edge[stateEdgePortion] 
        node[edgeLabel, text width=12.25em, yshift=1.5em]{\emph{Timeout after two maximum segment lifetimes (2*MSL)}} 
        (timeWait2ClosedD);
        \draw (timeWait2ClosedD) edge[stateEdge] ($(closedStart.north) + (-0.5em,0)$);
        
        % draw dotted lines around passive and active closes
        \begin{pgfonlayer}{background}
            \draw [join=round,black,dotted] ($(closeWait.north west) + (-1em, -1em)$) rectangle ($(lastAck.south east) + (1em, 1em)$);
            \draw [join=round,black,dotted] ($(finWait1.north west) + (-1em, -1em)$) rectangle ($(timeWait.south east) + (1em, 1em)$);
        \end{pgfonlayer}
        
        \end{tikzpicture}
        \caption{TCP automaton.}
        \label{fig:TCPAutomaton}
    \end{figure}

    As it can be seen in the state machine, there exists different states that are
    subject to change when a message is segment is sent or received or when an action
    is done by the user. A label $A/B$ on an edge refers to a stimuli performed on the socket
    (the receiption of a message, a user action...) for $A$ and a flag sent for $B$.
    More precisely, for $A$, a text in italic shape refers to an action perform by
    the user (a call of a user function) or when it's a timeout, by a timer and a ACK,
    SYN or FIN refers to a flag contained in a received message. The flags in $B$ refer
    to the flags sent in response of the stimuli $A$.  Without giving
    unnecessary details on the format of a TCP header, we can describe the different
    flags that can be contained in a TCP header:
    \begin{description}
        \item[ACK] Acknowledgment field significant. The last message received by the sender
        is acknowledge. A field of the header contains the number of this segment.
        \item[SYN] Synchronize sequence number. This flag is sent in order to establish
        a connection.
        \item[FIN] No more data from sender. This flag is sent in order to close the
        connection.
    \end{description}
    
    Different states can be taken by a socket during its lifetime depending on the state
    of the connection, and also depending on the state of the remote TCP state. Each
    state has its own signification:
    \begin{description}
        \item[CLOSED] represents no connection state at all.
        \item[LISTEN] represents waiting for a connection request from any remote
        TCP and port.
        \item[SYN-SENT] represents waiting for a matching connection request
        after having sent a connection request.
        \item[SYN-RECEIVED] represents waiting for a confirming connection
        request acknowledgment after having both received and sent a
        connection request.
        \item[ESTABLISHED] represents an open connection, data received can be
        delivered to the user. The normal state for the data transfer phase
        of the connection.
        \item[FIN-WAIT-1] represents waiting for a connection termination request
        from the remote TCP, or an acknowledgment of the connection
        termination request previously sent.
        \item[FIN-WAIT-2] represents waiting for a connection termination request
        from the remote TCP.
        \item[CLOSE-WAIT] represents waiting for a connection termination request
        from the local user.
        \item[CLOSING] represents waiting for a connection termination request
        acknowledgment from the remote TCP.
        \item[LAST-ACK] represents waiting for an acknowledgment of the
        connection termination request previously sent to the remote TCP
        (which includes an acknowledgment of its connection termination
        request).
        \item[TIME-WAIT] represents waiting for enough time to pass to be sure
        the remote TCP received the acknowledgment of its connection
        termination request.
    \end{description}

    For more details on how two TCP can establish a connection, the reader can refer
    to the TCP norm where pleinty of scenario are described and explained, and more
    details are given on the state and segments that can be sent.


    \subsubsection{Multithreading in the implementation}

    Different threads can interact with a socket. The TCP norm gives an example with
    three threads: one for the \emph{user calls}, one for the \emph{arriving segments}
    and one for the \emph{timers}. This design has been adopted in CycloneTCP.
    
    \paragraph{User calls}
    User calls refers to functions that can be called by the user to control the connection,
    send, or received data: OPEN, CLOSE, ABORT, SEND, RECEIVED. Transition between state of
    the connection can happen during the call of these function since there are made to control
    the connection.

    \paragraph{Arriving segments}
    In this threads, the received segments are processed. The corresponding messages are sent back.
    Transition between state can happen here. For example, this is the case when a message containing
    a SYN is received when the socket is in the LISTEN state. It will automatically send a SYN + ACK in
    response, and change its state for SYN-RECEIVED.

    \paragraph{Timers}
    The timers control the timeouts like the retransmission timeout to retransmit a message, or
    the time-wait timeout to close the connection after an amont of time. Then, transition can also
    happen in this threads.

    To sum up, a single socket can be seen as a shared structure over multiples threads, that can all
    manipulate it and change its fields. The schema illustrates that.
    
    Only one thread can perform an operation on the socket at the same time. The access to the fields of
    the socket are protected by mutex.

    Two threads can communicate synchronously or asynchronously together. The synchronous communications are based on
    the interface provided by the OS, in particular with events.

    \begin{tikzpicture}
        \node [draw, ellipse] (S) at (2, 2) {Socket};
        \node [draw, text width=2.5cm, anchor=north] (T1) at (-2,0) {\textbf{TIMER TASK} \\
                                                Timeout when need};
        \node [draw, text width=2.5cm, anchor=north] (T2) at (2,0) {\textbf{USER TASK} \\
                                                Controling the connection on the user side};
        \node [draw, text width=2.5cm, anchor=north] (T3) at (6, 0) {\textbf{RECEIVED TASK} \\
                                                Processing received messages};
        \draw[->] (T1) -- (S);
        \draw[->] (T2) -- (S);
        \draw[->] (T3) -- (S);
        \draw[<->, dashed] (T1) -- (T2);
        \draw[<->, dashed] (T2) -- (T3);
        
        \draw [->] (4.3,2) -- (4.9,2);
        \node [anchor=west] at (5,2) {Operation};
        \draw[<->, dashed] (4.3,1.3) -- (4.9,1.3);
        \node [anchor=west, text width=2.7cm] at (5, 1.3) {Synchronous communications};
    \end{tikzpicture}


    \section{Challenges}

    \subsection{Main focus for the verification}

    The TCP norm defines a lot of behavior that could be verified by automatic proof.
    Here is a non exhaustive list of what could be done:
    \begin{itemize}
        \item Verification of the transitions between the states.
        \item Integrity of the messages sent, \textit{i.e.} we could check that the sent
        message contains the correct flag and the correct sequence and acknowledgement numbers.
        \item Integrity of the messages received, \textit{i.e.} we could check that the
        messages received are correctly processed in regard of the flags they contain.
        \item Functionnal correctness of the user functions in regard to their specifications.
    \end{itemize}

    Some choices have had to be done in regard the short time devolved to the internship, and
    not every aspect of the TCP norm has been prooved. However, some aspects have been selected
    for the challenge or the importance they represent. A list of these aspects is presented
    here and the choices will be motivated in the next subsections. First of all, we have wanted
    to improve the interface of the functions. The other point was to improved the safety of the
    protocol itself.

    \subsubsection{Improve functions interface}

    One of the main problems pointed by the main writter of the CycloneTCP library is that users
    do not correctly used the API supplied. As a result, some calls of
    functions can be incorrect, either because the arguments are incorrect, or because the
    return code of the previous functions has not been checked, which drive to an
    incorrect code.

    \subsubsection{Respect to the protocol}

    To ensure the safety of the library, it is necessary to ensure that the functions really
    do what they are supposed to do. It is a part of the job that has been done. More
    especially we have wanted to checked if the transition machine is respected by all the
    user functions. We have also tried to ensure the correctness of the function called
    regarding to the TCP state of the socket before the call to respect the specifications
    given in the norm.


    \subsection{Technical problems encountered}

    The multiples tasks and the changes that can happen at every moment in one
    task or another make the verification hard. Multiples interactions exist
    between the multiples threads: synchronous and asynchronous.
    All these interraction have to be considered if we want to write correct contracts
    in regard of what could be done in other threads.

    As SPARK does not have a native mode to deal with concurrency, we have to
    model these different interactions by hands by writing assertions that
    modify the state of the socket as another thread could do it. In particular
    the problem has been encountered when we tried to write contracts for the correctness
    of the user functions. More details and explainations will be given in the following
    section, where we will investigate the solution found to these technical problems.

    \section{Solutions found}

    \subsection{Order to call the functions}

    This part mainly focussed on the high level user functions, the socket functions.
    The socket functions are the one manipulated by the user to perform operations on
    the network. They are located in the files \texttt{socket\_interface.ad(b|s)}.

    It is clear that there exist an order on which the functions have to be called.
    This order can be determined by the norm, and must respect the order given by the
    graph in figure \ref{fig:TCPAutomaton}.
    Then, we want post- and pre-conditions to model a partial order on the calls of the function.
    If two functions $f_1$ and $f_2$ are ordered such that $f_1 \preceq f_2$ where $\preceq$ is
    a relation over the oder of which functions have to be called, then we want that the
    post-condition of $f_1$ implies the precondition of $f_2$.
    
    We will give an example over functions \lstinline[language=Ada]{Socket_Connect} and
    \lstinline[language=Ada]{Socket_Send}. The function \lstinline[language=Ada]{Socket_Connect}
    try to connect to a distant TCP. If the connection succeed, the remote IP address of the distant
    TCP is set in the field \lstinline[language=Ada]{S_Remote_Ip_Addr} of the \lstinline[language=Ada]{Sock}
    structure. When a user call the function \lstinline[language=Ada]{Socket_Send}, we want to ensure that
    the connection has already been established. This is why a precondition of this function is
    \lstinline[language=Ada]{Is_Initialized_Ip(Sock.S_Remote_Ip_Addr)}.


    \begin{figure}
        \begin{lstlisting}[language=Ada]
procedure Socket_Connect
    (Sock           : in out Not_Null_Socket;
     Remote_Ip_Addr : in     IpAddr;
     Remote_Port    : in     Port;
     Error          :    out Error_T)
  with
   Pre => Is_Initialized_Ip (Remote_Ip_Addr),
   Contract_Cases => (
     Sock.S_Type = SOCKET_TYPE_STREAM =>
       (if Error = NO_ERROR then
         Sock.S_Type = Sock.S_Type'Old and then
         Sock.S_Protocol = Sock.S_Protocol'Old and then
         Is_Initialized_Ip (Sock.S_localIpAddr) and then
         Sock.S_Local_Port = Sock.S_Local_Port'Old and then
         Sock.S_Remote_Ip_Addr = Remote_Ip_Addr and then
         Sock.S_Remote_Port = Remote_Port and then
         Sock.State = TCP_STATE_ESTABLISHED
       else
         Sock.S_Type = Sock.S_Type'Old and then
         Sock.S_Protocol = Sock.S_Protocol'Old)
     others => True)

procedure Socket_Send
    (Sock    : in out Not_Null_Socket;
     Data    : in     Send_Buffer;
     Written :    out Natural;
     Flags   :        Socket_Flags;
     Error   :    out Error_T)
  with
   Pre  =>
     Is_Initialized_Ip(Sock.S_Remote_Ip_Addr)
        \end{lstlisting}
        \caption{An example of how functions calls can be ordered by Pre- and Post-conditions.}
        \label{code:FunOrdered}
    \end{figure}

    \subsection{Check of return code}

    An observation made by Clément Zeller, the main programmer of the library is that customers
    do not always think to check the return code of the socket user functions, that can fail.
    If the return code is not checked, some assumption on the result cannot be done.

    The post-conditions as we have written them in SPARK, ensure that the return code is checked
    before continuating processing. Figure \ref{code:FunOrdered} shows this mechanism for the
    procedure \lstinline[language=Ada]{Socket_Connect}. The post-condition filters the cases
    where \lstinline{Error} is \lstinline{NO_ERROR} and if \lstinline{Error} takes another value.
    As a result, a user who would write an incorrect code such as
    \begin{lstlisting}[language=Ada]
    Socket_Connect (Sock, Remote_Ip_Addr, Port, Error);
    Socket_Send (Sock, Data, Written, Flags, Error);
    \end{lstlisting}
    would be warned by gnatprove with a message such as
    \begin{verbatim}
    medium: precondition might fail.
    \end{verbatim}
    whereas the following code is correct
    \begin{lstlisting}[language=Ada]
    Socket_Connect (Sock, Remote_Ip_Addr, Port, Error);
    if Error /= NO_ERROR then
        return;
    end if;
    Socket_Send (Sock, Data, Written, Flags, Error);
    \end{lstlisting}



    % \subsection{Liberties taken with the norm}

    % For some operations in the norm, if it is called when the socket in a particular
    % state, the function is assumed to return an error (see page 56 for an example of that).
    % I have made the choice to directly discrimine this choice in the pre condition
    % to allow user to check if its call is legal or not.

    \subsection{Verification of the state machine}

    The aim of this part is to explain how we have done to check that the transitions done
    in a function respect the TCP automaton. In particular, we were interested in verifying
    the high level user functions. These functions are not the one in which most of the
    transitions are done. Even, the verification of these functions is important in order
    to guarantee the safety of the whole library. The functions of interest are located in
    the file \texttt{tcp\_interface.ad(b|s)}.

    \subsubsection{Overview of the concurrency challenge}

    To ensure the safety of our library, we need to consider all what can happen everywhere in
    the library. All our functions are protected by mutex, which means that only one operation
    can be performed at the same time on a socket. Interractions must be considered at two
    locations: between the function calls, when the mutex is released and during the function
    call, when the program waits for an event. We will explore in the two next sections how we
    have dealt with this two different concurrent mechanisms.

    Before everything else, let's see where the interference mainly comes from, and how we have
    done to ensure that all have been considered.

    \subsubsection{Process segments functions}

    Almost all the transitions are done in the file \texttt{tcp\_fsm.c}. This file has not been
    translated in SPARK by a lack of time. Then we do not have strong guaranties on its functions
    behavior. However, for formal verification we need to know what is done in the functions of
    this file, because a wrong contract can make all the verification wrong.

    The file \texttt{tcp\_fsm.c} is in charge of processing the incoming segments. The reader is
    strongly encouraged to have a look at this file. The main function of this file
    \texttt{tcpProcessSegment} look for the socket corresponding to the received segment, and then
    according to the TCP state of the socket, process the segment as expected by calling one of
    the function \texttt{tcpState<StateName>}. The functions familly \texttt{tcpState<StateName>}
    check the information contained in the segment and can perform change of state in the socket
    struct depending on the flags received.

    In these functions, change of state can be performed as mentionned, through the function
    \texttt{tcpChangeState}. To summarize what is done when a message is received, rather than
    reading the code and locate all the calls to functions \texttt{tcpChangeState}, we have used
    Klee\footnote{\url{https://klee.github.io}}. It helped to find behavior that had not been
    imagined at first. Anyway, we cannot state that all the work done with klee is complete, and
    we would need to rewrite this part in SPARK to have a code formally proved.

    All what is related to klee is present in the folder \texttt{klee/} and can be compiled and run
    thanks to the makefile to reproduce the results. Roughtly, what is done is creating a random
    incomming message, put the socket in the desired state and call the desired function to see what
    final states can be obtain.

    Finally, all the result found by klee has been reported in the function \lstinline[language=Ada]{Tcp_Process_One_Segment}.
    This function is essential for all the verification of concurrent parts and is reused everywhere
    the concurrency is involved to compute the results.

    % The functions used to process the segments are written in C and we have not changed
    % them. We have just extracted some information, like the changes of state that can be
    % produced by the reception of a message.

    % To ensure the correctness of the extracted information, we have used Klee, a symbolic
    % virtual machine. It allows to consider all the paths taken in the function and check
    % if the contracts written in SPARK respects the C implementation.
    % \textbf{\itshape Show the example where I found an error.}
    
    % A goal to achieve would be to rewrite this part in SPARK to have more guaranties.
    % However, Klee is a tool that helps to find errors.

    \subsubsection{Concurrency: asynchronous changes of state}

    Between the user functions calls, segment can be received and these receptions can drive to
    change of state of the socket. Between two function calls, an infinite number of segments
    can be potentially receive. The reception of one or zero segment is modeled by the function
    \lstinline[language=Ada]{Tcp_Process_One_Segment} in term of change of states. Then we have
    to consider the iteration of \lstinline[language=Ada]{Tcp_Process_One_Segment} in order to
    compute the result of the reception of multiple message.

    \begin{algorithm}[t]
        \SetKwFunction{ProcessSegm}{\lstinline[language=Ada]{Tcp\_Process\_Segment}}
        \SetKwProg{Fn}{function}{}{end}
        \Fn{\ProcessSegm{Socket}}{
            $S_{last} := \text{\textit{Socket}}$\;
            $S := S_{last}$\;
            \For{$i=1$ \KwTo $3$}{
                $S_{last} :=$ \lstinline[language=Ada]{Tcp_Process_One_Segment}($S_{last}$) \;
                $S := S \cup S_{last}$\;
            }
            \KwRet{$S$}\;
        }
        \caption{Reflexive and transitive closure of \lstinline[language=Ada]{Tcp_Process_One_Segment}}
        \label{algo:tcpProcessSegment}
    \end{algorithm}

    Let $\rightarrow$ be the transition function in the TCP automaton restrited to the transitions
    that can be performed by the reception of a message and its automatic response mechanism.
    Then we have $\rightarrow = \text{\lstinline[language=Ada]{Tcp_Process_One_Segment}}$ and
    we need to consider the reflexive transitive closure $\rightarrow^*$ of $\rightarrow$, with
    \[\rightarrow^* = \bigcup_{n\in\mathbb{N}} \rightarrow^n\]
    Now, by examining the TCP automaton in figure \ref{fig:TCPAutomaton}, we see that all state is
    only reachable by a state at a distance less than 3 (the maximum path is between SYN-SENT and
    CLOSE-WAIT if we pass by state SYN-RECEIVED and ESTABLISHED) without action by the user. Since
    we only consider the transitive closure in term of states, we can significantly reduce the number
    of iteration of $\rightarrow$ to compute $\rightarrow^*$ and finally we get:
    \[\rightarrow^* = \bigcup_{n=1}^3 \rightarrow^n\]
    It follows that algorithm \ref{algo:tcpProcessSegment} is enough good to compute the transitive closure of the function
    \lstinline[language=Ada]{Tcp_Process_One_Segment} by taking advantage of the fact that SPARK can unroll
    small loops to obtain more precise results.

    In the user functions, we have added a call to \lstinline[language=Ada]{Tcp_Process_Segment} everywhere
    there is a call to \lstinline{Os_Acquire_Mutex (Net_Mutex)}. Doing that helps to ensure that all the
    possible that all the possible input states are have been considered.

    \subsubsection{Concurrency: Synchronous exchange}

    The other mechanism to deal with concurrency is probably more difficult to apprehend and the
    use of the function \lstinline[language=Ada]{Tcp_Process_One_Segment} is even more noticeable.
    
    The C code contains a function \lstinline[language=C]{tcpWaitForEvents} in the file \texttt{tcp\_misc.c}
    that checks if the event is true when the function is called, by calling the function
    \lstinline[language=C]{tcpUpdateEvents}. If the wait is not completed at the time the function is
    called, then the mutex that was previously locked is released until the event become waited happen.
    Then, everything can happen meanwhile.
    
    In the code, the function \lstinline[language=C]{tcpUpdateEvents} is called at different locations
    and can raise the desired event. In particular this function is called each time the state of
    the socket is changed. This is sufficient for our purpose since we are only interested in the state
    changes.

    When a segment is received, the function \lstinline[language=C]{tcpUpdateEvents} is called if a
    change of state happens. Then, we can consider the algorithm \ref{algo:waitForEvents} to compute the set of possible
    final states after the wait. \textit{(This is done in the function \lstinline[language=Ada]{Tcp_Wait_For_Events_Proof},
    the function dedicated to proof in file \texttt{tcp\_misc\_binding.adb}.)}

    \begin{algorithm}[t]
        \SetKwFunction{ProcessSegm}{\lstinline[language=Ada]{Tcp\_Wait\_For\_Events}}
        \SetKwProg{Fn}{function}{}{end}
        \Fn{\ProcessSegm{Socket, Event, Event\_Mask}}{
            $S_{last} := \text{\textit{Socket}}$\;
            $S := S_{last}$\;
            $E :=$ \lstinline[language=Ada]{Tcp_Process_One_Segment}($S_{last}$)\;
            \If{$E \wedge \text{Event\_Mask} \neq 0$}{
                \KwRet{$S$}\;
            }
            \For{$i=1$ \KwTo $3$}{
                $S_{last} :=$ \lstinline[language=Ada]{Tcp_Process_One_Segment}($S_{last}$) \;
                $S := S \cup S_{last}$\;
                $E :=$ \lstinline[language=Ada]{Tcp_Process_One_Segment}($S_{last}$)\;
                \If{$E \wedge \text{Event\_Mask} \neq 0$}{
                    \KwRet{$S$}\;
                }
            }
            \KwRet{$\emptyset$}\;
        }
        \caption{Function to compute the possible state after when waiting for a particular event.}
        \label{algo:waitForEvents}
    \end{algorithm}

    We can compute precisely the state reach for each event waited thanks to the fact that SPARK
    unroll loops.

    \textcolor{red}{\paragraph{Weakness} If two threads want to lock the same mutex at the same time, which one win?}


    \section{Future work}

    
\end{document}
