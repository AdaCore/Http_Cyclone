\documentclass[runningheads]{llncs}

\usepackage{listings}
\usepackage[colorlinks]{hyperref}

\usepackage{xcolor}

\usepackage[ruled]{algorithm2e}
\usepackage{amsmath,amsfonts}

\usepackage[utf8]{inputenc}

\lstset{
    basicstyle=\fontsize{9}{9}\selectfont\ttfamily,
    keywordstyle=\color{blue!50}\bfseries
}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing, patterns}

\usepackage{subcaption}

\title{Verification of a TCP/IP stack}

\author{Guillaume Cluzel\inst{1,2} \and
        Yannick Moy\inst{1} \and
        Cl\'ement Zeller\inst{3}}


        \institute{Adacore \and
        \'Ecole Normale Sup\'erieure de Lyon \and
        Oryx Embedded}


\begin{document}

\authorrunning{G. Cluzel et al.} %, Y. Moy and C. Zeller}

\maketitle

\begin{abstract}
    The abstract should briefly summarize the contents of the paper in
    150--250 words.

    \keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}

    In the development of the Internet, there is a protocol that has a very special place: TCP.
    It has been described by Vincent Cerf and Bob Kahn who can be considered as the fathers for the Internet
    for their work, and the protocol has later been standardized in a RFC norm~\cite{rfc793}.
    Since this date, the TCP has been widely used on the Internet as the underlying protocol for application layers such as HTTP,
    FTP or TLS. TCP uses itself an underlying protocol to work, the Internet layer IP protocol which is itself
    based on a link layer, such as Ethernet. This stacking of protocols is referred to as the TCP/IP stack.

    The last decade has seen a growing interest for security and privacy in all the fields where computers are
    involved. The development of safe applications thanks to static analyzers and formal methods, that was first
    restricted to critical embedded software with the Astr\'ee analyzer~\cite{cousot2005astree} or the B method, are
    now adopted on a larger scale. New tools have been developed to promote the use of formal methods. Among them we
    can mention the SMT-solvers Z3~\cite{de2008z3} and Alt-Ergo~\cite{conchon:hal-01960203},
    the higher level language F*~\cite{mumon} that can prove assertions
    using these SMT-solvers or the more automatic static analyzer by abstract interpretation Frama-C~\cite{cuoq2012frama}
    that can help to identify undefined behaviors in C programs. Theorem provers, such as Coq or Isabelle, are another class
    of tools, where proofs are done manually.

    In the domain of networking and cryptography, these tools have been used to make secure implementations.
    Recently, Reiher and al have proposed a domain-specific language, RecordFlux~\cite{Reiher2019RecordFluxFM},
    to specify the message formats for real world protocols, that is written in SPARK.
    This is also the goal followed by the Everest project~\cite{bhargavan2017everest}.
    The authors implemented cryptographic functions such as AES or
    SHA2 as well as TLS, the cryptographic protocol that provides security
    to HTTPS and is its heart. The implementation is written
    in F* and is a combination of several sub-project such as miTLS~\cite{bhargavan2013implementing}
    or HACL*~\cite{zinzindohoue2017hacl}. The weakness of the Everest project lies in its need to use the untrusted
    transport layer TCP. If a bug exists in the transport layer, it can also jeopardize the higher level layers.

    The importance of the TCP protocol in the network communications has driven some people to work
    on it and try to ensure the safety of the protocol. Among these works, in~\cite{smith1996formal}
    the author has tried to formally verify that a TCP implementation verify some specifications.
    Another work comes from Tom Ridge and al~\cite{ridge2008rigorous} who have implemented the TCP
    protocol in the HOL proof assistant.
    But only few works has been done. Doing formal verification on a TCP implementation face up to two
    problems. The first one is the complexity of the TCP protocol that is written to be concurrent.
    The second problem comes from the norm itself that is written in a natural, informal language: English.
    Then a lot of part are under specified and extracted strong specifications can be hard.
    As a result, it does not exists a safe implementation for TCP that can be used in the industry.

    Our approach has been to consider an existing implementation of a TCP/IP stack and replace and integrate
    some bricks by Ada/SPARK code.
    We have chosen the Oryx Embedded's library, CycloneTCP\footnote{\url{https://www.oryx-embedded.com/products/CycloneTCP.html}}.
    The library is written in C, which is suitable to interface with Ada/SPARK, and is developed to run
    on embedded processors. We focused our work on rewriting in SPARK the TCP protocol because of the importance
    it has in the network communication as well as the socket API to provide a safe interface to the programmers
    to use our safe TCP implementation.

    In the first section we explore more in details the TCP protocol and the state machine that governs the behavior of the connection.
    Then in the next section we explain how we have formalized and implemented in SPARK the TCP user functions and the socket API.
    Finally in the last section we present some results of our work, like the bugs that have been found and eliminated thanks to our
    new implementation.


\section{TCP protocol and CycloneTCP library}
\label{sec:TCP}

\subsection{TCP protocol}


\subsection{CycloneTCP library organisation}

    \input{OryxStack.tex}

    The CycloneTCP library is TCP/IP stack that implements network protocols. 
    Figure \ref{Fig:TcpStack} gives an overview of the different protocols supported. TCP and UDP protocols have a central place
    in the stack. An API is provided to use those network protocols: the Socket API. It is a common way to use transport protocols,
    and the application protocols in the stack, such as HTTP or FTP use it.

    The stack is particularly well adapted to embedded platforms and microcontrolers. As a result, the code is written
    to compile on those platforms and to be used with different real time OS, like for intance FreeRTOS.
    Hence, a model based on multiple tasks has been adopted to implement the TCP protocol as defined in the norm, with,
    in addition, complex cooperation mechanisms. A task is dedicated to the user code, another to timers, and the last is
    assigned to the processing of incoming segments.

    In this part we should present:
    \begin{itemize}
        \item The TCP protocol
        \begin{itemize}
            \item Different states
            \item Flags that can be received (mainly SYN, ACK, FIN \& RST)
            \item State machine
            \item User functions
            \item Precise that most of transitions are done when a message is received and then, outside of the user functions.
        \end{itemize}
        \item The CycloneTCP library. Present the different caracteristics, in particular
        \begin{itemize}
            \item The task model adopted to be run on a RT OS. (A task dedicated to user task, another to timers, and the last to incoming messages processing).
            \item The socket API that is provided to use UDP and TCP protocols.
        \end{itemize}
    \end{itemize}

    Any other suggestion? (2/3 pages max).

    Figures à inclures ici:
    \begin{itemize}
        \item Une figure qui présente l'automate de transition. Expliquer que certaines transition sont effectuées par une action de l'utilisateur,
              et que d'autres sont effectuées quand un segment est reçu.
    \end{itemize}

\section{Specification Techniques Used}

\subsection{The SPARK Programming Language}

Ada is a general-purpose procedural programming language. The design of the Ada
language puts great emphasis on the safety and correctness of the program. This
objective is realized by using a readable syntax that uses keywords instead of
symbols where reasonable. The type system is strong and strict and many
potential violations of type constraints can be detected statically by the
compiler. If not, a run-time check is inserted into the program, to guarantee
the detection of incorrect situations. Ada 2012 introduced contract based
programming to Ada. In particular, it is possible to attach pre- and
postconditions to subprograms\footnote{In Ada, a distinction is made between
  functions that return a value, and procedures, which do
  not. \emph{Subprogram} is the term that designates both.}.  These conditions
can be checked during the execution of the program, just like assertions.

SPARK~\cite{mccormick2015building} is the name of a platform that provides
formal verification for Ada. It uses the user-provided contracts and attempts
to prove that the runtime checks cannot fail and that postconditions are
established by the corresponding subprograms.  As formal verification for the
whole Ada language would be intractable, SPARK is also the name of the subset
of the Ada language that is supported by the SPARK tool called
GNATprove\footnote{\url{http://docs.adacore.com/spark2014-docs/html/ug/}}.
This subset contains almost all features of Ada, though sometimes in a
restricted form.  In particular, expressions should be free from side effects,
and aliasing is forbidden (no two variables should share the same memory
location or overlap in memory), including when using pointers thanks to the use
of an ownership policy~\cite{dross2020recursive}.  This restriction greatly
simplifies the memory model used in the SPARK tool: any program variables can
be reasoned about independently from other variables.

GNATprove performs two kinds of analysis modularly on individual subprograms:
information flow to detect reads of uninitialized data and violations of flow
contracts; deductive verification based on the Why3 platform to generate
verification conditions for SMT solvers via a weakest-precondition calculus to
detect possible runtime errors and violations of functional contracts.

\subsection{Interfacing SPARK and C Code}

describe import of C subprograms/export of SPARK subprograms, and how data
types are mapped, also contracts on imported subprograms

\subsection{Dealing with Pointers}

both at top-level and as fields in structures. explain how it relies on the
ownership model. maybe a little bit on dynamic allocation/deallocation (which
will introduce the section later on memory leaks)

\subsection{Specifying the Frame Condition}

describe how models of sockets are defined and used in contracts, based on
ghost code, delta aggregates and Old attribute


\section{Verification of the TCP protocol and the Socket API}

    Our work is focused on the key elements of the CycloneTCP library: the sockets and TCP protocol itself.
    These two parts have been replaced by SPARK code and the absence of run-time errors has been proved for
    these parts.
    However, to be integrated with the existing library, it has been necessary to reuse existing C code
    as an untrested black box, for which we cannot have strong guarantees. Figure \ref{Fig:TcpStack} gives an overview of
    what have been translated and what have been reused. The box for TCP is hatched because only the user level functions
    has been translated in SPARK. The parsing and processing of incoming segment is let to the C code.
    Thus, other techniques and tools have helped the verification process, in particular for the TCP part. They are presented in this section.
    The source code of the reworked TCP/IP stack can be found on Github\footnote{\url{https://github.com/AdaCore/Http_Cyclone}}.

\subsection{Hardening the user's socket API}

\begin{figure}[t]
\begin{subfigure}{\textwidth}
\begin{lstlisting}[language=C, frame=bottomline]
Socket *socketOpen(uint_t type, uint_t protocol);
error_t socketConnect(Socket *socket, IpAddr *remoteIpAddr,
                      uint16_t remotePort);
\end{lstlisting}
\caption{C interface.}
\label{Fig:socketInterface:C}
\end{subfigure}
\begin{subfigure}{\textwidth}
\begin{lstlisting}[language=Ada, frame=bottomline]
type Socket_Struct is private;
type Socket is access Socket_Struct;
subtype Not_Null_Socket is not null Socket;
type Socket_Type is (SOCKET_TYPE_STREAM, SOCKET_TYPE_DGRAM);
type Socket_Proto is (SOCKET_IP_PROTO_TCP, SOCKET_IP_PROTO_UDP);

procedure Socket_Open
    (Sock       :    out Socket;
     S_Type     : in     Socket_Type;
     S_Protocol : in     Socket_Protocol)
with
    Post => (if Sock /= null then
        Sock.S_Type = S_Type and then
        not Is_Initialized_Ip(Sock.S_Remote_Ip_Addr) and then
        not Is_Initialized_Ip(Sock.S_localIpAddr));

procedure Socket_Connect
    (Sock           : in out Not_Null_Socket;
     Remote_Ip_Addr : in     IpAddr;
     Remote_Port    : in     Port;
     Error          :    out Error_T)
with
    Pre => Is_Initialized_Ip (Remote_Ip_Addr) and then
           Remote_Port > 0,
    Post => (if Error = NO_ERROR then
            Is_Initialized_Ip(Sock.S_localIpAddr) and then
            Sock.S_localIpAddr = Remote_Ip_Addr);
\end{lstlisting}
\caption{SPARK interface.}
\label{Fig:socketInterface:SPARK}
\end{subfigure}
\caption{Comparison between the C and the SPARK interface for \texttt{Socket\_Open} et \texttt{Socket\_Connect}.}
\label{Fig:socketInterface}
\end{figure}

    The socket API is a set of functions used to communicate with the protocol stack. These are therefore the functions used
    by programmers in their programs to use network protocols. However, one of the most significant problems pointed to by the
    primary author of the CycloneTCP library is the incorrect usage of the library's API. More specifically, the library's users
    tend to call the API functions with wrong arguments and they tend to forget to check the value of the return code of the
    function call before continuing the processing. This can lead to incorrect program behaviors when an error occurs in a function
    and it can be difficult to debug.

    In order to design a better socket API, we have taken advantage of the strong-typing characteristic of Ada,
    and the features of the SPARK language, in particular the functional specifications.

\subsubsection{Using types to carry information}

    Strong-typing is a first mechanism to ensure correctness of programs and exclude a range of programing errors. Meaningful names for
    variables and types give a hint about the subprogram behavior, but also the valid input values accepted.
    Figure \ref{Fig:socketInterface} is a comparison between the interface of the C functions of the original library
    \lstinline{socketOpen} and \lstinline{socketConnect} and their SPARK version \lstinline{Socket_Open} and
    \lstinline{Socket_Connect}. The C function \lstinline{socketOpen} takes two arguments, the type of the socket and the protocol,
    both as unsigned integers and it returns a new socket in case of success.
    Its SPARK equivalent takes its two arguments, type and protocol, as enumeration values, which ensures correct calls
    of this function. Indeed, all the unsigned values that do not correspond to any protocol or any type of socket are eliminated.

    In SPARK, types can be constrained by a valid range of values. Another kind of constraint on types can appear in
    access types. The example on figure \ref{Fig:socketInterface:SPARK} shows a such mechanism for the type \lstinline{Not_Null_Socket},
    that is a socket with a constraint that states that the pointer has to be not null. The function \lstinline{socketConnect},
    used to connect to a remote server, requires a socket not null. While the C function contains defensive code to ensure that
    the socket passed as first argument is not null, \lstinline{Socket_Connect} directly uses information on the type of the argument
    \lstinline{Sock} to know that the socket is not null. Moreover, this information can be checked statically with GNATprove.
    Then removing the defensive code has two interests: first, it reduces the size of the program by removing lines of code,
    and secondly it reduces the number of instructions to execute, and then the global execution time.


\subsubsection{Order of the functions call}

    The TCP connection follows an order of execution as seen in the section \ref{sec:TCP}: the connection is first opened,
    then the data are sent and received, and finally the connection can be closed. Since the sockets are an interface to use
    network protocols, they follow the same order of execution. Thus, an order can be enforced thanks to the pre- and postconditions.
    If a function $f_1$ must be executed before a function $f_2$, the strategy is to add a postcondition on the socket on $f_1$
    that is also a precondition for $f_2$. Then, for the precondition of $f_2$ to be true, the function $f_1$ must have been called first.
    Such postcondition is presented on figure \ref{Fig:socketInterface:SPARK} for the function \lstinline{Socket_Connect}. After its
    execution, the field \lstinline{S_Remote_Ip_Addr} of the socket \lstinline{Sock}. Then, since all the functions to send or receive
    data and to close the connection require a connection established, these functions have a precondition that contains a condition
    that states that the condition is established, which can be written as
    \begin{lstlisting}
Pre => Is_Ip_Initialized(Sock.S_Remote_Ip_Addr);
    \end{lstlisting}
    and because the function \lstinline{Socket_Connect} is the only one that can initialize this value, the order is respected
    if and only if the code is valid.

    The same mechanism is used with the functions \lstinline{Socket_Open} that create a valid socket when the function
    succeeds and \lstinline{Socket_Connect} that require a valid not null socket.

    GNATprove can prove that the order of the calls is respected, and then it can invalidate an incorrect program without requiring any
    tests. It helps programmers to write correct programs.


\subsubsection{Checking error codes}

    Most of the functions of the socket API can fail. To know if the function has failed or not, and error code is returned.
    It must be checked by the caller before continuing processing at the risk of leading to an incorrect state.
    In the previous paragraph we explained that the functions that send or receive data check in their precondition if the connection
    has been initialized or not, by checking the field \lstinline{S_Remote_Ip_Addr}, and we explained that this value is initialized
    by \lstinline{Socket_Connect}. The presence in the postcondition of \lstinline{Socket_Connect} or if statement
    \lstinline{(if Error = NO_ERROR then ...)} makes that \lstinline{S_Remote_Ip_Addr} is initialized only when no error occurs during
    the execution of the function. Thanks to the mechanism exposed in the previous section the next function can only be called
    if it is known that no error has occurred previously.

    Let \lstinline{Socket_Send} be the function to send data. The following example of code is incorrect because if \lstinline{Error} is
    different to \lstinline{NO_ERROR}, nothing ensures that \lstinline{S_Remote_Ip_Addr} is initialized.
    \begin{lstlisting}[language=Ada]
Socket_Connect(Sock, Remote_Ip_Addr, Remote_Port, Error);
-- GNATprove: medium: precondition might fail.
Socket_Send(Sock, Data, Written, Flags, Error);
    \end{lstlisting}
    In comparison this second example of code produces no error because when \lstinline{Socket_Send} is called, GNATprove knows that
    \lstinline{ERROR} is equal to \lstinline{NO_ERROR} and then \lstinline{S_Remote_Ip_Addr} is initialized.
    \begin{lstlisting}[language=Ada]
Socket_Connect(Sock, Remote_Ip_Addr, Remote_Port, Error);
if Error = NO_ERROR then
    Socket_Send(Sock, Data, Written, Flags, Error);
end if;
    \end{lstlisting}

    The same mechanism can be observed on figure \ref{Fig:socketInterface:SPARK}. The user has to test if the socket returned by
    \lstinline{Socket_Open} is null or not before calling \lstinline{Socket_Connect}, otherwise GNATprove will emit a message.

    Thanks to this use of GNATprove, one can ensure the correct use of the socket API, by ensuring a correct order for the
    calls of the functions and ensuring that error codes are checked.


\subsection{Conformance to the TCP protocol}

    The user functions of the TCP protocol have been rewritten in SPARK. Besides proving the absence of run-time error in these functions,
    it has been possible to check that some properties of the TCP protocol are not violated in the code.

\subsubsection{Extracting a specification from the TCP norm}

    Extracting a specification is mandatory to provide later functional contracts to the user functions.
    That can be achieved by reading the norm. However, the norm is underspecified in many cases and only one possible implementation
    is depicted. Thus, the specifications we have extracted are conformant with the norm but they differ a little to
    what can be found in the RFC.

    Among the specifications we have extracted:
    \begin{itemize}
        \item The transitions between the states must respect the order given by the state machine described
              in figure \ref{Fig:statemachine}.
              In particular, a transition from a state to another is valid only if there exists a transition in the state machine
              between these two states.
        \item User functions contains functional specifications in the norm, that describe what have to be done when the function
              is called depending on the state of the socket~\cite[p.~52]{rfc793}.
              In particular, a socket in some state will return an error for certain calls of user functions. Figure \ref{Fig:constraint}
              lists all the constraints on the state of the socket before and after the call.
    \end{itemize}

\subsubsection{Rewriting TCP user functions}

    The user functions have been translated in SPARK to prove the absence of run-time errors in them. The low level IP functions
    that are called are assumed to be correct and then are used as an untrusted black box. They are supposed to not interact with TCP
    special fields. However, there exists another kind of subprogram that interacts and can modify the state of the socket
    during the execution of the program: the procedure \lstinline{Tcp_Wait_For_Events}. This procedure is called when the code needs
    to wait for an event to become true. The event waited can become true, for example, when a segment is received. But when a
    segment is received, the state of state can change. Then it is necessary to know what are the exact possible states when the
    procedure \lstinline{Tcp_Wait_For_Events} returns if we want to be sure that there is no violation of the norm in the further transitions.

    SPARK does not have a very advanced native way to deal with concurrency. In particular, it is not possible for the tool to infer precisely the
    interferences that comes from other tasks. Thus, using SPARK is not the right way to do, and a manual solution has been considered. It consists
    of analysing what is done in other tasks. Then a contract can be added to \lstinline{Tcp_Wait_For_Events} to describe the possible
    interractions of the other tasks during the wait.


\subsubsection{The use of KLEE to extract contracts}

    When a TCP segment is received, that segment is processed through a C function named \lstinline{tcpProcessSegment}.
    Depending on the flags contains in the segment, and the state of the socket at the moment of the reception of the segment, different
    transitions can be done. Reading the code might be enough to infer contracts connecting the state before the reception of the segment
    and after. But from experience it is not enough and a more formal approach is necessary. Translating this function in SPARK to analyze
    its behavior would have been a correct way to proceed, but because of a lack of time, another method has been chosen: symbolic execution.

    Symbolic execution is a means to execute a program using symbolic variables instead of concrete values. It accumulates contraints
    on those values which are used to generate proof obligations. Symbolic execution has been successfully used with other verification
    methods. Indeed, in~\cite{vanoverberghe2008using} the authors present how to use symbolic execution to improve deductive verification,
    and in~\cite{kassios2012comparing} the authors explain that symbolic execution can be good at infering contracts.
    For our work, KLEE has been used. It is built on top of LLVM as it takes LLVM bytecode in input
    and works well with C code thanks to a very simple interface.

    In order to extract contracts from the C function \lstinline{tcpProcessSegment}, we have started by building a small main function that
    simulates the reception of a segment. This function is then executed by KLEE. More precisely, first, with the KLEE intrinsic functions, we
    create a symbolic segment (representing any segment that can be received). Secondly, the socket is changed for a particular state $S_1$. Thirdly, the
    function is executed by KLEE. After its call, an assertion about the states $S'_1, \dots, S'_k$ of the socket after the execution
    of the function is added to check what are the resulting states. The states $S'_1, \dots, S'_k$ are extracted from the norm and adapted to the CycloneTCP
    implementation that can differ on some points.
    After this work, we then have a postcondition for \lstinline{tcpProcessSegment}, that can be reported in the SPARK code for further proofs, of the form:
    \begin{lstlisting}[language=Ada,mathescape=true]
    if Sock.State'Old = $S_1$ then Sock.State in $S'_1$ | $S'_2$ | ... | $S'_k$
    \end{lstlisting}


\subsubsection{Solution to the concurrency challenge}

    The previous part shows how we can compute all the transitions that can be done when a single message is received.
    It is now necessary to understand how the waiting procedure \lstinline{Tcp_Wait_For_Events} works.
    When it is called, it checks if the event is already true, thanks to a call to the function \lstinline{Tcp_Update_Events}.
    If it is not the case, the mutex that enforces the mutual exclusion of access to the socket is unlocked.
    Messages can be received until the event waited becomes true.
    Once a reception makes true the event, the function \lstinline{Tcp_Wait_For_Events} locks again the mutex and returns.
    A possible algorithm to simulate the reception of segment and compute the least set of states that can result of the wait can be done
    by the algorithm \ref{algo:waitForEvents}.

    \begin{algorithm}
        \SetKwFunction{ProcessSegm}{\lstinline[language=Ada]{Tcp\_Wait\_For\_Events}}
        \SetKwProg{Fn}{function}{}{end}
        \Fn{\ProcessSegm{Socket, Event, Event\_Mask}}{
            $S_{last} := \text{\textit{Socket}}$\;
            $S := S_{last}$\;
            $E :=$ \lstinline[language=Ada]{Tcp_Update_Events}($S_{last}$)\;
            \If{$(E\ \&\ \text{Event\_Mask}) \neq 0$}{
                \KwRet{$S$}\;
            }
            \For{$i=1$ \KwTo $3$}{
                $S_{last} :=$ \lstinline[language=Ada]{Tcp_Process_One_Segment}($S_{last}$) \;
                $S := S \cup S_{last}$\;
                $E :=$ \lstinline[language=Ada]{Tcp_Update_Events}($S_{last}$)\;
                \If{$(E\ \&\ \text{Event\_Mask}) \neq 0$}{
                    \KwRet{$S$}\;
                }
            }
            \KwRet{$\emptyset$}\;
        }
        \caption{Function to compute the possible states after a wait for a particular event.}
        \label{algo:waitForEvents}
    \end{algorithm}

\section{Results and bugs found}

    \begin{itemize}
        \item Bug de concurrence -> SPARK
        \item Memory leak -> SPARK
        \item Problèmes trouvés.
        \item Résultats sur la nouvelle implémentation (performance, taille du code).
        \item Activation des préconditions pour voir si elles sont toutes valides.
    \end{itemize}



\section{Conclusion and future work}

    The use of SPARK for the verification of the TCP protocol has given good results. It has helped to find bugs
    in the existing implementation. But more than finding bugs, the interest of this work lie in the face that it is
    a big step toward a secure implementation. It has been proved by the tool GNATprove that our implementation is free
    of run-time errors and that all the transitions in the TCP state machine are done with respect to the norm.

    However weeknesses exist our implementation, in particular because all the underlying layers are still written in C.
    The principal function of those layers is to format packet before they are sent, or parse incoming packets, check
    their integrity and transmit the resulting payload to the corresponding upper level layer.
    This processing part can be a source of errors and bugs as explain in~\cite{Reiher2019RecordFluxFM}.
    Using the RecordFlux DSL to parse the packets of the different protocols is the next step to make the stack safer.
    Using RecordFlux to parse TCP message would be a big step to finish the translation of the TCP protocol in SPARK.
    The postconditions extracted by KLEE could be proved by GNATprove for a safer result.

    Our verification of the TCP protocol only focuses on the validity of the transitions in the TCP state machine,
    but some other properties are formulated in the TCP norm, and could be verified in the implementation to make
    it even more robust.




\bibliographystyle{splncs04}
\bibliography{biblio}


\end{document}
